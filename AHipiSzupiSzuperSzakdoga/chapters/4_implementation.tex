\Chapter{Megvalósítás}

Ez a fejezet mutatja be a megvalósítás lépéseit.
Itt lehet az esetlegesen előforduló technikai nehézségeket említeni.
Be lehet már mutatni a program elkészült részeit.

Meg lehet mutatni az elkészített programkód érdekesebb részeit.
(Az érdekesebb részek bemutatására kellene szorítkozni.
Többségében a szöveges leírásnak kellene benne lennie.
Abból lehet kiindulni, hogy a forráskód a dolgozathoz elérhető, azt nem kell magába a dolgozatba bemásolni, elegendő csak behivatkozni.)

A dolgozatban szereplő forráskódrészletekhez külön vannak programnyelvenként stílusok.
Python esetében például így néz ki egy formázott kódrészlet.
\begin{python}
import sys

if __name__ == '__main__':
    pass
\end{python}

A stílusfájlok a \texttt{styles} jegyzékben találhatók.
A stílusok között szerepel még C++, Java és Rust stílusfájl.
Ezek használatához a \texttt{dolgozat.tex} fájl elején \texttt{usepackage} paranccsal hozzá kell adni a stílust, majd a stílusfájl nevével megegyező környezetet lehet használni.
További példaként C++ forráskód esetében ez így szerepel.
\begin{cpp}
#include <iostream>

class Sample : public Object
{
    // An empty class definition
}
\end{cpp}
Stílusfájlokból elegendő csak annyit meghagyni, amennyire a dolgozatban szükség van.
Más, C szintaktikájú nyelvekhez (mint például a JavaScript és C\#) a Java vagy C++ stílusfájlok átszerkesztésére van szükség.
(Elegendő lehet csak a fájlnevet átírni, és a fájlban a környezet nevét.)

Nyers adatok, parancssori kimenetek megjelenítéséhez a \texttt{verbatim} környezetet lehet használni.
\begin{verbatim}
$ some commands with arguments
1 2 3 4 5
$ _
\end{verbatim}

A kutatás jellegű témáknál ez a fejezet gyakorlatilag kimaradhat.
Helyette inkább a fő vizsgálati módszerek, kutatási irányok kaphatnak külön-külön fejezeteket.
A program úgy dolgozik, mint ahogy a felhasználó tenné papíron. Kiszámolja a kapott értékek es tömegek arányát, és ez alapján felállít egy új sorrendet: a legnagyobb aránypár kerül az elsőhelyre és a legkisebb a végére. Ezután megnézni, hogy a legnagyobb aránnyal rendelkező belefér e a zsákba. Ha igen, akkor 1 -es kerül az első (nulladik) indexre, és nézi a következő elemet. Ha egy olyan elemet találunk, ami már nem fér bele, akkor egy tört kerül megfelelő indexre, hogy a tömegének hanyadrésze fér bele a zsákba. A maradék elemeket kinullázza. A Z érték is megfelelően kiszámításra kerül. Ezután végig megyünk a fán. Az összes helyre, ahova tört került, megnézzük 1 és 0 érték fixálásával és a szülők már fixált értékeinek öröklésével  a Z értéket, hogy megtaláljuk azt a kombinációt, amikor a legtöbb elem ténylegesen belefér a zsákba.
A program a kapott érték és tömeg értékeket külön 1-1 tömben tárolja. Az aranyTomb függvény segítségével kerül feltöltésre a harmadik tömb, ahova a kiszámolja a paraméterként kapott tömeg és érék tömbökből az elemek arányát. Ezután következik az arányok szerinti rendezés a rendezés metódus segítségével. Paraméterként megkapja mindhárom tömböt. A Java Arrays.sort() metódusával rendezem növekvő sorrendbe az aránytömb értékeit, majd egy ciklus és egy segédváltozó segítésével megfordítom az értékek sorrendjét, ezzel csökkenő értékbe rendezem őket. Ezáltál az arányok tömbje már megfelelő, de az értékek és a hozzájuk tartozó tömegek továbbra is rendezetlenek. Ezért két darab for ciklus segítésével össze hasonlítom az eredeteti arány tömböt, és a rendezetett, hogy megtaláljam, melyik elem melyik indexről melyik indexre került. Ha megvan, akkor a tömeg és értékek tömb egyes elemeinek indexét is hasonlóan mozgatom. 
A rendezés után jön a fa egyes leveleinek kiszámítása az eredmeny metódus segítségével. Ez a metódus paraméterként a már rendezett tömeg és érték tömböt, a hátizsak méretét és egy láncolt listát kap. Emellett a metóduson belül szükség volt egy újabb tömbre, amiben azt tárólom, hogy a levél mely már fixelt elemeket örökli, és azok helyén nullával vagy eggyel számoljon. Ha az adott elem szabad, akkor -1 az értéke, ha fix nullánál 0, egynél pedig 1. Kezdetben minden értéke -1. Mérete megegyezik a kapott elemek számával. A listához hozzá adok a kapott elemek számával megegyező elemet és plusz mégegyet, ahova Z értéke kerül.
Ezekután elkezdtem egy ciklus segítségével vizsgálni, hogy belefér e az aktuális elem a hátizsákba, azaz a hátizsák szabad mérete nagyobb vagy egyenlő e az aktuális elem tömegével. Ha igen, akkor az eredmény lista ciklusváltozó aktuális értékével megegyező indexre egy 1 -es érték kerül, a hátizsák szabad értékét csökkentem az aktuális elem tömegével, és z értékét növelem az akutális elem értékével. A Z értékét végül a lista végére, a tömeg tömb hosszúságával megegyező indexű elem helyére írom. Amennyiben az aktuális elem már nem fér bele teljes egészében a hátizsákba, akkor meghivjuk a nemFerBele metódust. Ebben a metódusban a ciklusváltozó aktuális értékével megegyező indexre a hátizsák szabad területe és az aktuális elem tömegének aránya kerül. A Z értékhez pedig hozzá adjuk ennek az aránynak és elem értékének szorzatát. Emellett a fixek tömb i-edik elemét 0 -ra állítjuk. A következő lépésben a tortHelyereNulla metódust hívjuk meg. Paraméterként a tömeg, érték és fixek tömböt, a hátizsák méretét, az eredménylistát, és a ciklus változó aktuális értékét kapja meg. 
Első lépésben bővíti az eredmény listának elemeinek a számát eggyel többel, mint a tömbök mérete. A hanyadik globális változó méretét növeljük eggyel, jelezve, hogy már egy szinttel méllyebben vagyunk a fában. Egy ciklus segítségével végig megyünk a fixek tömbön. Ha az aktuális érték 1, azaz az egyik szülőtől azt örökölte, hogy annak az elemnek fixen be kell kerülnie a hátizsákba, akkor bele is kerül: csökken a hátizsák mérete, a Z értéke pedig a bekerült elem értékével növekszik. Az eredmény lista végére bekerül a Z értéke. Az eredmény lista hanyadik nevű változóval megszorzott ciklus változó értékének megfelelő helyére egy 1 -es kerül. Ha a fixek tömb értéke 0, akkor a hanyadik nevű változóval megszorzott ciklus változó értékének megfelelő helyére 0 kerül. Ez esetben sem a Z értéke, sem a hátizsák szabad mérete nem változik. Az eredmény metódushoz hasonlóan elkezdi az eredmény listát feltölteni egy plusz felétellel: csak abban az esetben számol, ha fixek tömb ciklus változó szerinti értéke -1, azaz egy nem fix elemről van szó. Ha olyan elemhez érkeztünk, ami már nem fér teljes egészében bele a hátizsákba, akkor ismét a nemFerBele metódust hívjuk meg. Most is eljutunk a tortHelyereNulla metódus meghívásáig, és egyre mélyebbre megyünk a fában, a törtek helyére mindig 0 értéket fixálva. Amint végig értünk, lépkedünk vissza egy-egy szintet, és a fixek tömb i-edik elemét 1 -re állítjuk, és a tortHelyerEgy metódust hívjuk meg. Paraméterei ugyanazok, mint a tortHelyereNulla metódusnak. Az első lépés itt is az eredmény lista elemeinek bővítése annyi elemmel, ahány elem volt a bemenet, és még egy, a Z értékének, a hanyadik változót növeljük, és hátizsák eredeti méretét elmentjük. Ezután a fixek több értékei alapján csökkentjük a hátizsák szabad méretét, számoljuk a Z méretét, és az indexeket állítjuk 0-ra vagy 1 -re. Következőnek megvizsgáljuk, hogy a hátizsák nagyobb e, mint nulla. Ugyanis előfordulhat, hogy önmagukban a fixen zsákba került elemek sem férnek valójában bele a korlátba. Ha negatív lett a hátizsák szabad mérete nem megyünk tovább, töröljük a listából a metódus elején hozzáadott sorokat, és a hanyadik változó értékét csökkentjük eggyel, és a fixek tört tortHelyerEgy metódus meghívásakor paraméterként átadott i ciklusváltozó értékének megfelelő idexű elemét -1 -re állítjük, és visszatérünk korábbi metódus hívás helyére: a nemFerBele metódusba, ami ezután a return utasítással vissza adja a vezérlést a tortHelyereNulla metódusnak. Mivel lefutott mindkét metódushívás, a tört helyére be próbáltuk a nulla és egy értéket is, ezért ez is visszatér az előző hívásba, egy másik nemFerBele metódusba. Itt a fixek tömb i-edik eleme 1 -et kap, és meghívja a tortHelyerEgy metódust.
Ez addig folytatódik, amíg az összes lehetőségen végig nem megy, de listába csak azok a elemek kerülnek, ahol minden fix elem belefért a zsákba. A listában minden "blokk" annyi elemből áll, ahány elemű volt az input, és még egy elem, a Z értéke. Optimális megoldásnak azt a lehetőséget keressük, amikor egy elem vagy teljes egészében bekerült, vagy egyáltalán nem, és a Z értéke a lehető legmagasabb. Ennek az optimalis megoldásnak megtalalásához végig kell mennünk a lista minden Z -edik elemén, és megkeresni közülök a legnagyobbat, ahol az előtte álló bevitelielemszámnyi elem mindegyik egész szám. Ezt a maximumKiiras fügvény végzi. Kettő darab egymásbaágyazott ciklus dolgolzik: a külső a minden Z -edik elemet választja ki, tehát a ciklusváltozó bemenetielemszám + 1 értékkel növekszik minden iterációban. A belső ciklus pedig a Z értékekhez képest lépked egyessével az előző Z értékig, és nézi, hogy egész csupa egész szám található e a listában. Amennyiben igen, beállítjuk maxiumumnak. A függvény ezzel a maximum értékkel tér vissza.

go();
convertToArray();
aranyTomb();
rendezes();
tombMasolas();
eredmeny();
tortHelyereNulla();
torteHelyereEgy();
listaKiiras();
maximumKiiras();



------------------------------------------------------------------------------------
Szallitasifeladata
Ennél a feladatrész leprogramozásánál is papíron történő megoldás követését tűztem ki célul. A program a kezdeti megoldást tudja kiszámolni az északnyugat sarok módszerrel, lépésenként követhető módon. A bemenet egy tetszőleges nagyságú mátrix, de fontos, hogy csak kiegyensúlyozott szállítási feladatot tud megoldani.
A számítást a kezdetiMátrix metódus végzi. Egy while ciklussal kezdünk azzal a feltétellel, hogy addig ismétlünk, amíg a két darab ciklus változó nem érik el a mátrix utolsó sorának illetve oszlopának indexét.
Az oszlopVagySor függvény segítségével döntönem el hogy a két ciklus változó által kiválasztott elem sorának vagy oszlopának utolsó eleme a kisebb. Boolean típusú függvény, true értékkel tér vissza, ha a sor utolsó eleme a kisebb, és false -t, ha az oszlop utolsó eleme a kisebb. Amennyiben a két érték megegyezik, akkor is true értékkel tér vissza.
Ha a sor végén található elem a kisebb, akkor az ott találhatót egy változóba elmentjük, a két ciklusváltozóval kijelölt mátrix elem helyére beírjuk ezt az értéket, és egy for ciklus segítségével kinullázza a sort. Ezekután beállítom a ciklusváltozókat. Fontos, hogy abban a sorban, amit már kinulláztunk, azzal a program már ne foglalkozzon. Ezt a funkciót tölti be az i és j ciklusváltozó mellett bevezetett kezdoI és kezdoJ változó, amik segítségével az i és j váltózok abból megnövelt indexről indulnak, követve a már kinullázott sorokat, oszlopokat.
Ha a oszlop végén található elem a kisebb, akkor a folyamat hasonló az előzőekhez, annyi különbséggel, hogy az oszlop lesz kinullázva.
A program kiírja az összes lépést, szépen végig követhető, hogy melyik lépsében melyik fogyasztót elégítettük ki, vagy mely termelőtől szállítottuk el az összes anyagot.
A futás végén kalkulál egy kezdetleges megoldást. Feladattól függően elképzelhető, hogy ez már az optimális megoldás, de ezt a program jelenleg nem képes ellenőrizni, továbbfejlesztés szükséges.

matrixKiiras();
go();
kezdetiMegoldas();
oszlopVagySor();
megoldas();

-------------------------------------------------------------
Linearis egyenlettrendszerek megoldása pivotálássa


A programban tetszőleges nagyságú egyenletrendszereket tudunk megoldni pivotálással. A feladatot mátrix alakban kell feltöltenünk. Először kiválasztjuk, az ismeretlenek és az egyenletek számát, és a generálás gombra kattintva a kiválasztott nagyságú mátrixot kapunk egy plusz, B oszloppal.
A táblázatot feltöltjük az értékéekkel, majd kattintással kiválasztunk egy pivot elemet, és go -gomra kattintva pivotál. Kapunk hozzáfűzve az előzőhöz egy újabb táblázatot, a számolt eredményekkel. Itt ki tudunk választani egy újabb pivotelemet a folytatáshoz. 
A go gomb hatására egy-egy változóba elmentem a kiválasztott pivotelem koordinátáit, és egy tömbbe elmentem, hogy hanyadik sorból lett kiválasztva az első iterációban a pivot elem. Ez a végeredmény szempontjából lesz fontos, így tudom beazonosítani, hogy a végén a B oszlopban megmaradt értékek mely ismeretlenekhez tartoznak. Két másik boolean típusú tömb segítségével követem, hogy melyik sorból és melyik oszlopból választottam pivotelemet, melyiket vittem be a bázisba, honnan nem választhatok többet elemet. A program figyel erre, amennyiben egy olyan sorból vagy oszlopból választottunk pivotelemet, amit már korábban is választottunk, a go gomb megnyomására a program nem számol tovább.
A pivotálást egy pivotalas nevű függvény végzi. Először másolatot készít a bemenetként kapott kétdimenziós tömbről. Ezután a pivotelem sorát elosztja a pivotelemmel, és az oszlopát a pivotelem mínusz egyszeresével. A többi elemet a téglalapszabály alapján számolja:
Végül pedig a pivotelem helyére a pivotelem reciprokát írja.
Minden pivotálás végén ellenőrizzük, hogy lehetséges e még pivot elemet választani. Ha már nem, akkor vége a feladatnak, és lefut a megallpitas függvény, és egy szövegdobozba írja a megoldást, amik a következők lehetnek:
Nincs megoldás.
Egy megoldás van, és ki is írja az X értékeket.
Végtelen sok megoldás van. 























